import time
from abc import abstractmethod
from pathlib import Path
from typing import List

from .environment import Config


class ExploitChecker:
    '''
    The base class for checkers which helps to find out whether different types of exploits
    were successful.
    '''

    @staticmethod
    def list() -> List[str]:
        '''
        Returns a list of the available exploit types.
        '''
        return ['arbitrary-write']

    @staticmethod
    def create(name: str, **kwargs) -> 'ExploitChecker':
        '''
        Creates a new `ExploitChecker` instance based on the name provided.

        Arguments:
            name: Name of the exploit checker. Has to be one of the values that `ExploitChecker.list()` returns.
            kwargs: The arguments to be provided to the concrete exploit checker constructor.

        Returns:
            The exploit which is an instance of the `ExploitChecker` class.
        '''
        exploit_checkers = {
            'arbitrary-write': ArbitraryWriteChecker
        }
        if name not in exploit_checkers:
            raise LookupError(f'Exploit checker \'{name}\' could not be found.')
        return exploit_checkers[name](**kwargs)

    @abstractmethod
    def prepare(self) -> None:
        '''
        Cleans up and prepares the environment of the exploit checker. After
        calling this function, `is_exploited()` has to return False.
        '''
        pass

    @abstractmethod
    def is_exploited(self) -> bool:
        '''
        Returns the exploit status. Should be called after the exploit was run to check
        its status.

        Returns:
            True if the exploit was successful, False otherwise.
        '''
        pass


class ArbitraryWriteChecker(ExploitChecker):
    '''
    A checker which checks for the exploits' capability to write to a filename 
    specified in the constructor.

    Arguments:
        filename: The filename that the exploits should write to.
        contents: The contents that the exploits should write to `filename`.
        wait: Seconds to wait before trying to access the file during the call to `is_exploited()`.
    '''

    def __init__(self, filename: Path | None = None, contents: str = 'exploited', wait: float = 1.0) -> None:
        if filename is None:
            self.filename = Config.ARBITRARY_WRITE_DIR / 'exploited.txt'
        else:
            self.filename = filename
        self.contents = contents
        self.wait = wait

    def prepare(self) -> None:
        if self.filename.exists():
            self.filename.unlink()
        self.filename.parent.mkdir(exist_ok=True, parents=True)

    def is_exploited(self) -> bool:
        time.sleep(self.wait)
        if not self.filename.exists():
            return False
        with open(self.filename, 'r') as f:
            data = f.read()
        return data.startswith(self.contents)
