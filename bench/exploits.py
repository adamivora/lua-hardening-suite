import shutil
from abc import abstractmethod
from pathlib import Path
from typing import List

from .compiler import command_to_nasm, nasm_to_lua_shellcode, w64devkit_call
from .environment import Config
from .exploit_checker import ArbitraryWriteChecker, ExploitChecker
from .interpreters import Interpreter
from .templates import escape_path, render_template


class Exploit:
    '''
    A base class for Lua exploits.
    '''

    @staticmethod
    def list() -> List[str]:
        '''
        Returns a list of the available exploits.
        '''
        return [
            'ffi_virtualalloc',
            'ffi_createprocess',
            'ffi_load',
            'std_io_write',
            'std_os_execute',
            'bytecode_corsix'
        ]

    @staticmethod
    def create(name: str) -> 'Exploit':
        '''
        Creates a new `Exploit` instance based on the name provided.

        Arguments:
            name: Name of the exploit. Has to be one of the values that `Exploit.list()` returns.

        Returns:
            The exploit which is an instance of the `Exploit` class.
        '''
        exploits = {
            'ffi_virtualalloc': FFIVirtualAlloc,
            'ffi_createprocess': FFICreateProcess,
            'ffi_load': FFILoad,
            'std_io_write': StdIOWrite,
            'std_os_execute': StdOSExecute,
            'bytecode_corsix': BytecodeCorsix
        }
        if name not in exploits:
            raise LookupError(f'Exploit \'{name}\' could not be found.')
        return exploits[name]()

    def __init__(self, name: str):
        self.name = name
        self.in_dir = Config.EXPLOITS_DIR / self.name
        self.out_dir = Config.TEMP_DIR / self.name

    def __repr__(self) -> str:
        return self.name

    def prepare(self) -> None:
        '''
        Prepares the exploit environment - copies over the exploit files from the source folder
        to the working directory.
        '''
        shutil.rmtree(self.out_dir, ignore_errors=True)
        shutil.copytree(self.in_dir, self.out_dir, dirs_exist_ok=True)

    def render(self, template_path: str, *args: str | Path, **kwargs: str | Path) -> None:
        '''
        A helper function for rendering the exploit's Jinja templates.

        Arguments:
            template_path: The path to the `.template` file, relative to the exploit directory.
            args: Arguments passed to `Template.render()`.
            kwargs: Keyword arguments passed to `Template.render()`.
        '''
        out_name = template_path.replace('.template', '')
        render_template(f'exploits/{self.name}/{template_path}', self.out_dir / out_name, *args, **kwargs)

    @abstractmethod
    def compile(self, lua: Interpreter, checker: ExploitChecker) -> None:
        '''
        Compiles the files needed for the exploit. Should be called after the `prepare()` method.
        After a successful compilation, `Exploit.exploit_path()` should contain the path to the
        exploit Lua file that will be run.

        Arguments:
            lua: A Lua interpreter used to compile some of the exploits' files, if needed.
                 The implementation should not contain any mitigations, as the exploit is
                 not being run yet.
            checker: An `ExploitChecker` instance which represents the type of exploit for
                     which the exploit should be compiled.
        '''
        pass

    def exploit_path(self) -> Path:
        '''
        Returns the path to the Lua file containing the exploit.
        '''
        return self.out_dir / 'exploit.lua'


class FFIVirtualAlloc(Exploit):
    '''
    An FFI exploit utilizing the VirtualAlloc function of the Win32 API to run shellcode
    which executes the payload.
    '''

    def __init__(self):
        super().__init__('ffi_virtualalloc')

    def compile(self, lua: Interpreter, checker: ExploitChecker):
        if not isinstance(checker, ArbitraryWriteChecker):
            raise RuntimeError(f'{type(checker).__name__} not supported by this exploit!')
        exploit_filename = checker.filename.resolve()
        exploit_contents = checker.contents
        command_payload = command_to_nasm(f'cmd.exe /c "echo {exploit_contents} > {exploit_filename}"')
        self.render('shellcode.nasm.template', COMMAND_PAYLOAD=command_payload)
        lua_shellcode = nasm_to_lua_shellcode(self.out_dir / 'shellcode.nasm')

        self.render('exploit.lua.template', SHELLCODE=lua_shellcode)


class FFICreateProcess(Exploit):
    '''
    An FFI exploit utilizing the CreateProcess function of the Win32 API to spawn a process
    which executes the payload.
    '''

    def __init__(self):
        super().__init__('ffi_createprocess')

    def compile(self, lua: Interpreter, checker: ExploitChecker):
        if not isinstance(checker, ArbitraryWriteChecker):
            raise RuntimeError(f'{type(checker).__name__} not supported by this exploit!')
        exploit_filename = checker.filename.resolve()
        exploit_contents = checker.contents
        self.render('exploit.lua.template', EXPLOIT_FILENAME=exploit_filename, EXPLOIT_CONTENTS=exploit_contents)


class FFILoad(Exploit):
    '''
    An FFI exploit utilizing a DLL file containing `dllmain` with the payload and the `ffi.load`
    function to load that DLL file.
    '''

    def __init__(self):
        super().__init__('ffi_load')

    def compile(self, lua: Interpreter, checker: ExploitChecker):
        if not isinstance(checker, ArbitraryWriteChecker):
            raise RuntimeError(f'{type(checker).__name__} not supported by this exploit!')
        exploit_filename = checker.filename.resolve()
        exploit_contents = checker.contents
        self.render('dllmain.c.template', EXPLOIT_FILENAME=escape_path(
            exploit_filename), EXPLOIT_CONTENTS=exploit_contents)
        w64devkit_call('cc.exe', '-o', 'dllmain.dll', '-s', '-shared',
                       'dllmain.c', '-Wl,--subsystem,windows', cwd=self.out_dir)
        self.render('exploit.lua.template', DLL_PATH=self.out_dir / 'dllmain.dll')


class StdIOWrite(Exploit):
    'An exploit using the `io.write` function from the Lua standard library.'

    def __init__(self):
        super().__init__('std_io_write')

    def compile(self, lua: Interpreter, checker: ExploitChecker):
        if not isinstance(checker, ArbitraryWriteChecker):
            raise RuntimeError(f'{type(checker).__name__} not supported by this exploit!')
        exploit_filename = checker.filename.resolve()
        exploit_contents = checker.contents
        self.render('exploit.lua.template', EXPLOIT_FILENAME=exploit_filename, EXPLOIT_CONTENTS=exploit_contents)


class StdOSExecute(Exploit):
    '''
    An exploit using the `os.execute` function from the Lua standard library.
    '''

    def __init__(self):
        super().__init__('std_os_execute')

    def compile(self, lua: Interpreter, checker: ExploitChecker):
        if not isinstance(checker, ArbitraryWriteChecker):
            raise RuntimeError(f'{type(checker).__name__} not supported by this exploit!')
        exploit_filename = checker.filename.resolve()
        exploit_contents = checker.contents
        self.render('exploit.lua.template', EXPLOIT_FILENAME=exploit_filename, EXPLOIT_CONTENTS=exploit_contents)


class BytecodeCorsix(Exploit):
    '''
    An instance of an exploit from Peter Cawley which was posted on
    https://www.corsix.org/content/malicious-luajit-bytecode. Crafted for a LuaJIT implementation
    from 2015, it allows to run arbitrary shellcode.
    '''

    def __init__(self):
        super().__init__('bytecode_corsix')

    def compile(self, lua: Interpreter, checker: ExploitChecker):
        if not isinstance(checker, ArbitraryWriteChecker):
            raise RuntimeError(f'{type(checker).__name__} not supported by this exploit!')
        exploit_filename = checker.filename.resolve()
        exploit_contents = checker.contents
        command_payload = command_to_nasm(f'cmd.exe /c "echo {exploit_contents} > {exploit_filename}"')
        self.render('shellcode.nasm.template', COMMAND_PAYLOAD=command_payload)
        lua_shellcode = nasm_to_lua_shellcode(self.out_dir / 'shellcode.nasm')
        self.render('make_exploit.lua.template', SHELLCODE=lua_shellcode)
        lua.run(self.out_dir / 'make_exploit.lua', cwd=self.out_dir)
